"""
Contains classes that represent messages sent down the wire between nodes on
the network. Also contains functions for encoding/decoding to/from
MessagePack.

Named tuples are used because they are lightweight, immutable and indexable
(thus mimicing the dict like structure of the msgpack encoded message passed
down the wire). See http://bugs.python.org/issue9391 for Hettinger's advice on
adding docstrings to namedtuples and the reason why the classes are declared
in the way that they are.
"""

# Copyright (C) 2012 Nicholas H.Tollervey.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from collections import namedtuple
import msgpack
from constants import ERRORS
from validators import VALIDATORS


class Error(namedtuple('Error',
                       ['uuid', 'code', 'title', 'details', 'version'])):
    """
    Represents an error message to be sent to the calling node on the network.

    * uuid - the request id that generated the error.
    * code - the code that identifies the specific error.
    * title - a description of the type of error generated.
    * details - any details that may be useful for diagnosing the error.
    * version - the protocol version the message conforms to.
    """
    pass


class Ping(namedtuple('Ping', ['uuid', 'version'])):
    """
    A "ping" message is sent to another node on the network to determine if it
    is still contactable.

    * uuid - the ping's request id (a random value generated by the requestor
             that uniquely identifies the request).
    * version - the protocol version the message conforms to.
    """
    pass


class Pong(namedtuple('Pong', ['uuid', 'version'])):
    """
    A "pong" message is sent as a response to a ping request.

    uuid - the ping request's id.
    version - the protocol version the message conforms to.
    """
    pass


class Store(namedtuple('Store', ['uuid', 'key', 'value', 'timestamp',
                                 'public_key', 'name', 'meta', 'sig',
                                 'version'])):
    """
    A "store" message instructs another node on the network to store the given
    key/value pair.

    * uuid - the Store request's id (generated by the requestee).
    * key - the SHA1 value of the compound key used as the actual key on the
            DHT.
    * value - the value to be stored in the DHT.
    * timestamp - a timestamp indicating when this k/v was *originally*
                  generated as a floating point number representing the time in
                  seconds since the Epoch (so called POSIX time, see
                  https://en.wikipedia.org/wiki/Unix_time).
    * public_key - the public key of the person storing the value.
    * name - the human-readable name of the key.
    * meta - a list of tuples containing key/value strings for user defined
             metadata.
    * sig - the cryptographic signature for the value, timestamp, name and meta
            fields.
    * version - the protocol version the message conforms to.

    The provenance of the message is guaranteed through cryptography:

    The 'sig' field is created with the private key of the person storing the
    key/value pair. It's derived from the SHA1 hash of the SHA1 hashes of the
    'value', 'timestamp', 'name' and 'meta' fields. This mechanism ensures
    that the public_key used in the compound key is valid (i.e. it validates
    the sig field given the correct SHA1 hash) and also ensures that the
    'value', 'timestamp', 'name' and 'meta' fields have not been tampered with.

    The 'key' value is a compound key. It is a SHA1 hash of the SHA1 hashes of
    the 'public_key' and 'name' fields. The 'public_key' and 'name' fields are
    used to ensure that the compound 'key' field is correct.
    """
    pass


class FindNode(namedtuple('FindNode', ['uuid', 'key', 'version'])):
    """
    A "find node" message requests k nodes from the other node on the network
    that are closest to the given key.

    * uuid - the FindNode request's id (generated by the requestee).
    * key - the key in the DHT that is being targetted.
    * version - the protocol version the message conforms to.
    """
    pass


class Nodes(namedtuple('Nodes', ['uuid', 'nodes', 'version'])):
    """
    A response to either a FindNode or FindValue request that contains a list
    of nodes on the DHT that are close to the requested key.

    * uuid - the id of the request that is causing the response.
    * nodes - a list of nodes on the DHT that are close to the requested key.
    * version - the protocol version the message conforms to.
    """
    pass


class FindValue(namedtuple('FindValue', ['uuid', 'key', 'version'])):
    """
    A "find value" message will cause the other node to return the
    corresponding value if the given key is in its store. Otherwise it returns
    k nodes that it knows about that are closest to the given key.

    * uuid - the FindValue request's id (generated by the requestee).
    * key - the key in the DHT whose value is being requested.
    * version - the protocol version the message conforms to.
    """
    pass


class Value(namedtuple('Value', ['uuid', 'key', 'value', 'timestamp',
                                 'public_key', 'name', 'meta', 'sig',
                                 'version'])):
    """
    A response to a FindValue request. Contains all the information known by
    the responder about the key/value pair. Such complete information can be
    used to check the provenance of the data as described in the documentation
    for the Store message described above.

    * uuid - the id of the request that is causing the response.
    * key - the SHA1 value of the compound key used as the actual key on the
            DHT.
    * value - the value found in the DHT.
    * timestamp - a timestamp indicating when this k/v was *originally*
                  generated as a floating point number representing the time in
                  seconds since the Epoch (so called POSIX time, see
                  https://en.wikipedia.org/wiki/Unix_time).
    * public_key - the public key of the person who stored the value.
    * name - the human-readable name of the key.
    * meta - a list of tuples containing key/value strings for user defined
             metadata.
    * sig - the cryptographic signature for the value, timestamp, name and meta
            fields.
    * version - the protocol version the message conforms to.
    """
    pass


def to_msgpack(message):
    """
    Returns a string representation of the message object encoded using
    msgpack.
    """
    name = message.__class__.__name__.lower()
    data = message._asdict()
    data['message'] = name
    return msgpack.packb(data)


def from_msgpack(raw):
    """
    Returns an instance of the correct message class given the msgpack encoded
    data in the raw string. Encapsulates a variety of cleaning and checking of
    the raw message from the (potentially dangerous) external network.
    """
    try:
        data = msgpack.unpackb(raw)
    except Exception, ex:
        # Exception of first resort - msgpack can't deserialise the data.
        raise ValueError(1, ERRORS[1], {'exception': ex.message})
    message = data['message']
    # Explicit is better than implicit (Zen of Python).
    if message == 'error':
        return make_message(Error, data)
    elif message == 'ping':
        return make_message(Ping, data)
    elif message == 'pong':
        return make_message(Pong, data)
    elif message == 'store':
        return make_message(Store, data)
    elif message == 'findnode':
        return make_message(FindNode, data)
    elif message == 'nodes':
        return make_message(Nodes, data)
    elif message == 'findvalue':
        return make_message(FindValue, data)
    elif message == 'value':
        return make_message(Value, data)
    else:
        # Unknown request.
        raise ValueError(2, ERRORS[2], {'context':
                         '%s is not a valid message type.' % message})


def make_message(klass, data):
    """
    Returns an instance of the referenced namedtuple based class that is
    created from the validated data.
    """
    fields = klass._fields
    args = []
    errors = {}
    # Validate the values before adding them to the argument list. Store any
    # errors so they can be reported back.
    for field in fields:
        if not field in data:
            errors[field] = 'Missing field.'
            continue
        validator = VALIDATORS[field]
        value = data[field]
        if not validator(value):
            errors[field] = 'Invalid value.'
            continue
        args.append(value)
    if errors:
        raise ValueError(2, ERRORS[2], errors)
    else:
        return klass(*args)
