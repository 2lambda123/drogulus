"""
Contains classes that represent messages sent down the wire between nodes on
the network.

Named tuples are used because they are lightweight, immutable and indexable
(thus mimicing the dict like structure of the msgpack encoded message passed
down the wire).

Copyright (C) 2012 Nicholas H.Tollervey.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""
from collections import namedtuple
from Crypto.PublicKey import RSA
from Crypto.Hash import SHA
from Crypto.Signature import PKCS1_v1_5
import msgpack


"""
Defines the errors that can be reported between nodes in the DHT.
"""
ERRORS = {
    # The request simply didn't make any sense.
    1: 'Bad request',
    # The request was parsed but not recognised.
    2: 'Unknown request',
    # The request was parsed and recognised but the node encountered a problem
    # when dealing with it.
    3: 'Internal error',
    # The request was too big for the node to handle.
    4: 'Request too big',
    # Unsupported version of the protocol.
    5: 'Unsupported protocol',
    # The request could not be cryptographically verified.
    6: 'Unverifiable provenance',
    # The key / value pair did not match together as expected.
    7: 'Key mismatch'
}


"""
Represents an error message to be sent to the calling node on the network.

id - the request id that generated the error.
code - the code that identifies the specific error.
title - a description of the type of error generated.
details - any details that may be useful for diagnosing the error.
version - the protocol version the message conforms to.
"""
Error = namedtuple('Error', ['id', 'code', 'title', 'details', 'version'])


"""
A "ping" message is sent to another node on the network to determine if it
is still contactable.

id - the ping's request id (a random value generated by the requestor that
uniquely identifies the request).
version - the protocol version the message conforms to.
"""
Ping = namedtuple('Ping', ['id', 'version'])


"""
A "pong" message is sent as a response to a ping request.

id - the ping request's id.
version - the protocol version the message conforms to.
"""
Pong = namedtuple('Pong', ['id', 'version'])


"""
A "store" message instructs another node on the network to store the given
key/value pair.

id - the Store request's id (generated by the requestee).
key - the SHA1 value of the compound key used as the actual key on the DHT.
value - the value to be stored in the DHT.
time - a timestamp indicating when this k/v was *originally* generated as a
       string representing the date and time in ISO 8601 format.
public_key - the public key of the person storing the value.
name - the human-readable name of the key.
meta - a list of tuples containing key/value strings for user defined metadata.
sig - the cryptographic signature for the value, time, name and meta fields.
version - the protocol version the message conforms to.

The provenance of the message is guaranteed through cryptography:

The 'sig' field is created with the private key of the person storing the
key/value pair. It's derived from the SHA1 hash of the SHA1 hashes of the
'value', 'time', 'name' and 'meta' fields. This mechanism ensures that the
public_key used in the compound key is valid (i.e. it validates the sig field
given the correct SHA1 hash) and also ensures that the 'value', 'time', 'name'
and 'meta' fields have not been tampered with.

The 'key' value is a compound key. It is a SHA1 hash of the SHA1 hashes of the
'public_key' and 'name' fields. The 'public_key' and 'name' fields are used to
ensure that the compound 'key' field is correct.
"""
Store = namedtuple('Store', ['id', 'key', 'value', 'time', 'public_key',
    'name', 'meta', 'sig', 'version'])


"""
A "find node" message requests k nodes from the other node on the network that
are closest to the given key.

id - the FindNode request's id (generated by the requestee).
key - the key in the DHT that is being targetted.
version - the protocol version the message conforms to.
"""
FindNode = namedtuple('FindNode', ['id', 'key', 'version'])


"""
A response to either a FindNode or FindValue request that contains a list of
nodes on the DHT that are close to the requested key.

id - the id of the request that is causing the response.
nodes - a list of nodes on the DHT that are close to the requested key.
version - the protocol version the message conforms to.
"""
Nodes = namedtuple('Nodes', ['id', 'nodes', 'version'])


"""
A "find value" message will cause the other node to return the corresponding
value if the given key is in its store. Otherwise it returns k nodes that it
knows about that are closest to the given key.

id - the FindValue request's id (generated by the requestee).
key - the key in the DHT whose value is being requested.
version - the protocol version the message conforms to.
"""
FindValue = namedtuple('FindValue', ['id', 'key', 'version'])


"""
A response to a FindValue request. Contains all the information known by the
responder about the key/value pair. Such complete information can be used to
check the provenance of the data as described in the documentation for the
Store message described above.

id - the id of the request that is causing the response.
key - the SHA1 value of the compound key used as the actual key on the DHT.
value - the value found in the DHT.
time - a timestamp indicating when this k/v was *originally* generated as a
       string representing the date and time in ISO 8601 format.
public_key - the public key of the person who stored the value.
name - the human-readable name of the key.
meta - a list of tuples containing key/value strings for user defined metadata.
sig - the cryptographic signature for the value, time, name and meta fields.
version - the protocol version the message conforms to.
"""
Value = namedtuple('Value', ['id', 'key', 'value', 'time', 'public_key',
    'name', 'meta', 'sig', 'version'])


def generate_signature(value, time, name, meta, private_key):
    """
    Given the value, time, name and meta values of an outgoing value carrying
    message will use the private key to generate a cryptographic hash to the
    message to be used to sign / validate the message.

    The hash is created with the private key of the person storing the
    key/value pair. It is, in turn, based upon the SHA1 hash of the SHA1 hashes
    of the 'value', 'time', 'name' and 'meta' fields.

    This mechanism ensures that the public_key used in the compound key is
    valid (i.e. it creates the correct SHA1 hash) and also ensures that the
    'value', 'time', 'name' and 'meta' fields have not been tampered with.
    """
    compound_hash = construct_hash(value, time, name, meta)
    key = RSA.importKey(private_key)
    signer = PKCS1_v1_5.new(key)
    return signer.sign(compound_hash)


def validate_signature(value, time, name, meta, signature, public_key):
    """
    Uses the public key to validate the cryptographic signature based upon
    a hash of the value, time, name and meta values of a value carrying
    message.
    """
    generated_hash = construct_hash(value, time, name, meta)
    try:
        public_key = RSA.importKey(public_key.strip())
    except ValueError:
        # Catches malformed public keys.
        return False
    verifier = PKCS1_v1_5.new(public_key)
    return verifier.verify(generated_hash, signature)


def validate_key_value(key, message):
    """
    Given a key and associated message containing a value this function will
    return a tuple containing two fields:

    * A boolean to indicate its validity
    * An error number (in the case of a fail) or None (if success).

    The message contains a public_key field which is used to decrypt the
    message's 'hash' field into a list of SHA1 hashes of the message's 'value',
    'time', 'name' and 'meta' fields. This validates the provenance of the data
    and ensures that these fields have not been tampered with.

    Furthermore, once the validity of the public_key field is proven through
    the proceeding check, the 'key' field is verified to be a SHA1 hash of
    the SHA1 hashes of the 'public_key' and 'name' fields. This ensures the
    correct key is used to locate the data in the DHT.
    """
    if not validate_signature(message.value, message.time, message.name,
        message.meta, message.sig, message.public_key):
        # Invalid signature so bail with the appropriate error number
        return (False, 6)
    # If the signature is correct then the public key must be valid. Ensure
    # that the key used to store the value in the DHT is valid.
    generated_key = construct_key(message.public_key, message.name)
    if generated_key != key:
        # The key cannot be derived from the public_key and name fields.
        return (False, 7)
    # It checks out so return truthy.
    return (True, None)


def construct_hash(value, time, name, meta):
    """
    The hash is a SHA1 hash of the SHA1 hashes of the 'value', 'time', 'name'
    and 'meta' fields.

    It ensures that the 'value', 'time', 'name' and 'meta' fields have not
    been tampered with.
    """
    hashes = []
    for item in (value, time, name, meta):
        packed = msgpack.packb(item)
        hashed = SHA.new(packed).hexdigest()
        hashes.append(hashed)
    compound_hashes = ''.join(hashes)
    return SHA.new(compound_hashes)


def construct_key(public_key, name=''):
    """
    Given a string representation of a user's public key and the meaningful
    name of a key in the DHT will return a hex digest of the SHA1 hash to use
    as the actual key to use within the DHT.

    This ensures that the provenance (public key) and meaning of the DHT key
    determine its value.
    """
    # Simple normalisation: no spaces or newlines around the public key
    clean_public_key = public_key.strip()
    key_hash = SHA.new(clean_public_key)
    if name:
        # If the key has a meaningful name, create a compound key based upon
        # the SHA1 values of both the public_key and name.
        name_hash = SHA.new(name)
        compound_key = key_hash.hexdigest() + name_hash.hexdigest()
        compound_hash = SHA.new(compound_key)
        return compound_hash.hexdigest()
    else:
        # Not a compound key, so just return the hash of the public_key
        return key_hash.hexdigest()
