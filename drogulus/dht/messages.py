# -*- coding: utf-8 -*-
"""
Contains classes that define messages sent and received between nodes in the
DHT.

Every message contains five mandatory fields: uuid (identifying the
interaction), recipient (the public key of the recipient - which should match
the local node's public key), sender (the public key of the sender of the
message), version (indicating the version of the DHT the sender is running)
and seal (a cryptographic signature and proof of work provided by the sender
of the message to act as a "wax seal" to prove the sender's identity).

Named tuples are used because they are lightweight, immutable and indexable
(thus mimicing the dict like structure of the messages passed down the wire).
"""

from collections import namedtuple
from .validators import VALIDATORS


def _make_message_class(name, field_names, docstring=None):
    """
    Ensures all messages have the correct mandatory fields:

    uuid - identifies the interaction.
    recipient - the public key of the recipient (the local node's public key).
    sender - the public key of the sender of the message.
    reply_port - the port number to which we can connect back to the remote
                 node in future interactions.
    version - the protocol version the message conforms to.
    seal - a cryptographic signature provided by the sender of the message to
           act as a "wax seal" to prove the sender's identity.

    Also ensures that a passed in docstring is also added to the resulting
    class.
    """
    klass = namedtuple(name,
                       ['uuid', 'recipient', 'sender', 'reply_port',
                        'version', 'seal'] + field_names)
    if docstring:
        klass.__doc__ = docstring
    return klass


d = """
    Represents an error message to be sent to the calling node on the network.

    * uuid - the ID of the interaction that generated the error.
    * recipient - the public key of the recipient (the local node's public
      key).
    * sender - the public key of the sender of the message.
    * version - the protocol version the message conforms to.
    * seal - a cryptographic signature provided by the sender of the message
             to act as a "wax seal" to prove the sender's identity.
    * error - the type of error generated.
    * details - diagnostic details expressed as a dict of string key/values.
    """
Error = _make_message_class('Error', ['error', 'details'], d)


d = """
    A "ping" message is sent to another node on the network to determine if it
    is still contactable.

    * uuid - identifies the interaction.
    * recipient - the public key of the recipient (the local node's public
      key).
    * sender - the public key of the sender of the message.
    * version - the protocol version the message conforms to.
    * seal - a cryptographic signature provided by the sender of the message
             to act as a "wax seal" to prove the sender's identity.
    """
Ping = _make_message_class('Ping', [], d)


d = """
    A "pong" message is sent as a confirmation response. This is usually the
    result of a ping request but may be used to confirm reciept of any other
    sort of request when no further data is expected to be returned.

    * uuid - the interaction ID of the source of this response.
    * recipient - the public key of the recipient (the local node's public
      key).
    * sender - the public key of the sender of the message.
    * version - the protocol version the message conforms to.
    * seal - a cryptographic signature provided by the sender of the message
             to act as a "wax seal" to prove the sender's identity.
    """
Pong = _make_message_class('Pong', [], d)

d = """
    A "store" message instructs another node on the network to store the given
    key/value pair.

    * uuid - the ID of the Store request (generated by the requestee).
    * recipient - the public key of the recipient (the local node's public
      key).
    * sender - the public key of the sender of the message.
    * version - the protocol version the message conforms to.
    * seal - a cryptographic signature provided by the sender of the message
             to act as a "wax seal" to prove the sender's identity.
    * key - the hash used as the actual key on the DHT.
    * value - the value to be stored in the DHT.
    * timestamp - a timestamp indicating when this key/value pair was
                  *originally* generated as a float representing the time
                  in seconds since the Epoch (so called POSIX time, see
                  https://en.wikipedia.org/wiki/Unix_time).
    * expires - a timestamp indicating a point in time after which this
                key/value pair can be removed (expired) from the DHT. Expressed
                as a float representing the time in seconds since the Epoch
                (so called POSIX time). If the value is less than or equal to
                zero then the key/value pair should never expire.
    * created_with - the version of the protocol used to generate the item.
    * public_key - the public key of the person storing the value.
    * name - the human-readable name of the key.
    * signature - the cryptographic signature for the value, timestamp,
                  expires, created_with, public_key and name fields.

    The provenance of the message is guaranteed through cryptography:

    The 'signature' field is created with the private key of the person
    storing the key/value pair. It's derived from the SHA512 hash of the
    SHA512 hashes of the 'value', 'timestamp', 'expires', 'created_with',
    'public_key' and 'name' fields. This mechanism ensures that the
    public_key used in the compound key is valid (i.e. it validates the
    signature field given the correct SHA512 hash) and also ensures that the
    other fields have not been tampered with.

    The 'key' value is a compound key. It is a SHA512 hash of the SHA512 hashes
    of the 'public_key' and 'name' fields. The 'public_key' and 'name' fields
    are used to ensure that the compound 'key' field is correct.
    """
Store = _make_message_class('Store', ['key', 'value', 'timestamp', 'expires',
                                      'created_with', 'public_key', 'name',
                                      'signature'], d)


d = """
    A "find node" message requests k nodes from the other nodes on the network
    that are closest to the given key. The value k is the maximum number of
    nodes that can be stored in a k-bucket and is set in the constants module.
    The original Kademlia paper names this variable and recommends its value
    as 20.

    * uuid - the interaction ID for this request.
    * recipient - the public key of the recipient (the local node's public
      key).
    * sender - the public key of the sender of the message.
    * version - the protocol version the message conforms to.
    * seal - a cryptographic signature provided by the sender of the message
             to act as a "wax seal" to prove the sender's identity.
    * key - the key in the DHT that is being targetted.
    """
FindNode = _make_message_class('FindNode', ['key', ], d)

d = """
    A response to either a FindNode or FindValue request that contains a list
    of nodes on the DHT that are close to the requested key.

    * uuid - the interaction ID of the source of this response.
    * recipient - the public key of the recipient (the local node's public
      key).
    * sender - the public key of the sender of the message.
    * version - the protocol version the message conforms to.
    * seal - a cryptographic signature provided by the sender of the message
             to act as a "wax seal" to prove the sender's identity.
    * nodes - a list of nodes on the DHT that are close to the requested key.
    """
Nodes = _make_message_class('Nodes', ['nodes', ], d)


d = """
    A "find value" message will cause the other node to return the
    corresponding value if the given key is in its store. Otherwise it returns
    k nodes that it knows about that are closest to the given key.

    * uuid - the interaction ID for this request.
    * recipient - the public key of the recipient (the local node's public
      key).
    * sender - the public key of the sender of the message.
    * version - the protocol version the message conforms to.
    * seal - a cryptographic signature provided by the sender of the message
             to act as a "wax seal" to prove the sender's identity.
    * key - the key in the DHT whose value is being targetted.
    """
FindValue = _make_message_class('FindValue', ['key', ], d)

d = """
    A response to a FindValue request. Contains all the information known by
    the responder about the key/value pair. Such complete information can be
    used to check the provenance of the data as described in the documentation
    for the Store message described above.

    * uuid - the ID of the request that is causing the response.
    * recipient - the public key of the recipient (the local node's public
      key).
    * sender - the public key of the sender of the message.
    * version - the protocol version the message conforms to.
    * seal - a cryptographic signature provided by the sender of the message
             to act as a "wax seal" to prove the sender's identity.
    * key - the hash used as the actual key on the DHT.
    * value - the value to be stored in the DHT.
    * timestamp - a timestamp indicating when this key/value pair was
                  *originally* generated as a float representing the time
                  in seconds since the Epoch (so called POSIX time, see
                  https://en.wikipedia.org/wiki/Unix_time).
    * expires - a timestamp indicating a point in time after which this
                key/value pair can be removed (expired) from the DHT. Expressed
                as a float representing the time in seconds since the Epoch
                (so called POSIX time). If the value is less than or equal to
                zero then the key/value pair should never expire.
    * created_with - the version of the protocol used to generate the item.
    * public_key - the public key of the person storing the value.
    * name - the human-readable name of the key.
    * signature - the cryptographic signature for the value, timestamp,
                  expires, created_with, public_key and name fields.
    """
Value = _make_message_class('Value', ['key', 'value', 'timestamp', 'expires',
                                      'created_with', 'public_key', 'name',
                                      'signature'], d)


def to_dict(message):
    """
    Returns a dict representation of the message object.
    """
    name = message.__class__.__name__.lower()
    data = message._asdict()
    data['message'] = name
    return dict(data)


def from_dict(data):
    """
    Returns an instance of the correct message class given the data dict.
    Encapsulates a variety of cleaning and checking of the raw data from
    the (potentially dangerous) external network.
    """
    message = data['message']
    # Explicit is better than implicit (Zen of Python).
    if message == 'error':
        return make_message(Error, data)
    elif message == 'ping':
        return make_message(Ping, data)
    elif message == 'pong':
        return make_message(Pong, data)
    elif message == 'store':
        return make_message(Store, data)
    elif message == 'findnode':
        return make_message(FindNode, data)
    elif message == 'nodes':
        return make_message(Nodes, data)
    elif message == 'findvalue':
        return make_message(FindValue, data)
    elif message == 'value':
        return make_message(Value, data)
    else:
        # Unknown request.
        raise ValueError('%s is not a valid message type.' % message)


def make_message(klass, data):
    """
    Returns an instance of the referenced namedtuple based class that is
    created from the raw data. Data will be validated and an exception raised
    if this fails.
    """
    fields = klass._fields
    args = []
    errors = {}
    # Validate the values before adding them to the argument list. Store any
    # errors so they can be reported back.
    for field in fields:
        if field not in data:
            errors[field] = 'Missing field.'
            continue
        validator = VALIDATORS[field]
        value = data[field]
        if not validator(value):
            errors[field] = 'Invalid value.'
            continue
        args.append(value)
    if errors:
        raise ValueError(errors)
    else:
        return klass(*args)
